<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

        // function User(name , age){
        //     this.name = name;
        //     this.age=age;
        // }
        // let user1 = new User('mike',30);
        // console.log(user1)
        // let user2 = new User('mikey',20)
        // console.log(user2)



        // let a = 'age';
        // const User123 = {
        //     name : 'mike',
        //     [a]:30
        // }

        // console.log(User123)

        // let day = {
        //     mon : 'mon',
        //     thu : 'thu'
        // }
        // console.log(day)
        // let day2 = Object.assign({},day);
        // day2.mon = "월요일"
        // console.log(day2)
        // let day2 = Object.keys(day)
        // console.log(day2)
        // day2 = Object.values(day)
        // console.log(day2)
        // day2 =  Object.entries(day)
        // console.log(day2)
        // console.log(day2[0][1])
        // let day3=[
        //     ["name","mike"],
        //     ["age",30],
        //     ["gender","male"]
        // ]
        // let day4 = Object.fromEntries(day3);
        // console.log(day4)

        // const address = Symbol('add')
        // day.address = function(){
        //     console.log(this.mon)
        // }
        // day.address()

        // let num = 10;
        // num = num.toString(4)
        // console.log(num)

        // let ddd = "   '안녕하세요반갑습니다"
        // ddd= ddd.slice(3,-2)

            // ddd = ddd.substring(2,5)
            // ddd = ddd.substr(2,5)
            // ddd = ddd.trim()

        // console.log(ddd)

        // let list =[
        //     "01. 들어가며",
        //     "02.  js의 역사",
        //     "03. 자료형"
        // ]
        // let newList =[];
        // for(let i=0; i < list.length; i++){
        //     let tmp = list[i].split('.')
        //     newList[i] = tmp[1]
        // }

        // console.log(newList)


        // function hasCola(str){
        //     if(str.indexOf('콜라') >-1){
        //         console.log('금칙어가 있습니다.')
        //     }
        //     else{
        //         console.log("통과")
        //     }
        // }
        // function hasCola(str){
        //     if(str.includes('콜라') ){
        //         console.log('금칙어가 있습니다.')
        //     }
        //     else{
        //         console.log("통과")
        //     }
        // }
        //  hasCola('사이다가 짱이야')
        //  hasCola('아니야 콜라가 짱이야')
        
        
        
        // let arr =["mike","tom","jane"];
        // arr.forEach((name,index)=>{
        //     console.log(name)
        //     console.log(index)
        // })

        // let arr = [
        //     1,//0
        //     2,//1
        //     3,//2
        //     4,//3
        //     5,//4
        //     1,//5
        //     2,//6
        //     3,//7
        //     4//8
        // ]
        
        // // let tmp = arr.indexOf(3)
        // let tmp = arr.indexOf(2,5)
        // console.log(tmp)

            // let arr = [1,2,3,4,5];
            // const result = arr.find((item)=>{
            //     return item % 2 == 0;
            // })ㅁㄴ

            // console.log(result)



//         let message = (age < 3) ? '아기야 안녕?' : (age < 18) ? '안녕!' : (age < 100) ? '환영합니다!' :'나이가 아주 많으시거나, 나이가 아닌 값을 입력 하셨군요!';

// alert( message );



            // let user = {
            //     name:"mike",
            //     age:30,
            //     gender:"male"
            // };

            // user.name ="ban"
            // user.address = "NY";
            // console.log(user)

            // console.log("key" in user)

            // for (let key in user){
            //     // console.log(key);
            //     console.log(user[key])
            // }

        // let str = "hello\nnice to meet you"
        // console.log(str)
        // console.log(str.charAt(2))

//             function change(str){
//                 return str.length > 20?str = str.slice(0, 20)+"...":str;
//             }
// let test = " what i would like to tell on this topic is :";
// console.log(change(test))


    // let arr = new Array();
    // arr = ["사과","배","자두"]
    // console.log(arr)
    // console.log(arr.pop())
    // console.log(arr)
    
    // let num=[];

    // function add (){
    //     let tmp = prompt("숫자를 입력하세요");
    //     while(tmp == null){
    //         num.push(tmp)
    //     }
    // }
    // console.log(prompt(""))

// let arr =["사과", "배", "자두"]

// // delete arr[1];
// arr.splice(3,0,"포도")

// console.log(arr)

// let arr = ["t","e","s","t"]

// console.log(arr.slice(1,3))

// console.log(arr.concat("1"))

// console.log(hoi1);
// function hoi1() { return "hoi1 : 함수 호이스팅 입니다."; }
// var hoi1 = "hoi1 : 변수 호이스팅 입니다.";
// console.log(hoi1);

// // 변수 먼저 선언
// console.log(hoi2);
// var hoi2 = "hoi2 : 변수 호이스팅 입니다.";
// function hoi2() { return "hoi2 : 함수 호이스팅 입니다."; }
// // console.log(hoi2);

//       function User (name, age){
//           this.name = name;
//           this.age = age;
//           this.sayName = function(){
//               console.log(this.name)
//           }
//       }
//       let user1 = new User('mike',30);
//       user1.sayName();
//       console.log(user1)


   // const user = {
        //     name : "mike",
        //     age : 30,
        //     gender : "male"
        // }
        // let tmp = Object.entries(user);
        // console.log( tmp[1][1])
        

        // const id = Symbol('id');
        // const user = {
        //     name : "mike",
        //     age: 30,
        //     [id] : 'myid'
        // }
        // console.log(Object.entries(user))    
    

    // const user = {
    //     name : "mike",
    //     age : 30
    // }

    // const showName = Symbol('show name')
    // user[showName] = function(){
    //     console.log(this.name)
    // }
    // user[showName]()
    // for (let key in user){
    //     console.log("His " + key +" is " + user[key])
    //     // console.log(`His ${key} is ${user[key]}`)
    // }


//     let list = [
//         "01. 들어가며",
//         "02. js의 역사",
//         "03. 자료형",
//         "04. 함수",
//         "05. 배열"

//     ];

//     let newList = [];

//     for(let value of list){
//         newList.push(value.substring(4))
//     }
// console.log(newList)




// let arr = [5,15,6,82];

// let result = arr.sort((a,b)=>{
//     return a-b;
// });
// console.log(result)
// let result = 0;
// arr.forEach((value)=>{
//     result += value
// })
// console.log(result)
// let result = arr.reduce((prev,cur)=>{
//     return prev + cur;
// },0)
// console.log(result)

// let list = [
//     {name:"mike", age:30},
//     {name:"tom", age:10},
//     {name:"jane", age:27}
// ]

// let result = list.reduce((prev, cur) => {
//     if(cur.age >19){
//         prev.push(cur.name);

//     }
//     return prev;
// })
// let result = list.reduce((prev, cur) =>{
//     if (cur.age > 19){
//         prev.push(cur.name);
//     }
//     return prev;
// },0)
// console.log(result)
// let result = list.reduce((prev, cur)=>{
//     if(cur.age >19){
//         prev += cur.age
//         console.log(prev)
//     }
//     return prev ;
// },0)


// console.log(result)


// const Bmw = function(color){
//     const c = color;
//     this.getColor = function(){
//         console.log(c);
//     };
// };
// const x5 = new Bmw("red")

// x5.getColor();

// class Food {
//   constructor(name) {
//     this.name = name;
//     this.brands = [];
//   }
//   addBrand(brand) {
//     this.brands.push(brand)
//   }
//   print() {
//     console.log(`${this.name}을/를 파는 음식점들:`)
//     console.log(this.brands.join(', '));
//   }
// }

// const pizza = new Food('피자');
// pizza.addBrand('피자헛');
// pizza.addBrand('도미노 피자');

// const chicken = new Food('치킨');
// chicken.addBrand('굽네치킨');
// chicken.addBrand('BBQ');

// pizza.print()
// chicken.print();


/*
호이스팅 : 모든 선언들을 가장 위에서 읽는 현상 
        -변수 : var / let / const
          var는 전역변수이기에 가능 
          let / const 는 TDZ(Temporal Dead Zone) 때문에 호이스팅은 되지만 읽히지 않음
            TDZ : 일종의 사각지대로 스코프 내의 구간 / 
        - 함수 : 선언문 / 표현식
          선언문 : function name (){ ... }  -> 호이스팅이 실행되어 가장 위에 위치하여 실행 
          표현식 : let name = function (){ ... } -> 호이스팅이 되지만 선언문은 선언만 된 상태
        - 우선순위는 변수의 호이스팅이 먼저 함수의 호이스팅이 나중에 이루어져 값은 함수의 내용이 나오게 된다

변수 : 선언 / 초기화 / 할당의 순서로 생성

    var : 선언과 초기화 단계가 동시에 일어남 / 함수 스코프 : 전역변수 //예외로 함수 내부에서 var를 쓰면 함수 밖에서는 사용 못함
    let : 선언과 초기화 단계가 각각 일어나 그 사이의 지점이 TDZ (TDZ 때문에 호이스팅 되지 않아보임) / 블록스코프 ( 스코프 내에서만 알아볼수 있음 : 지역변수)
    const : 선언 +초기화 + 할당이 동일한 위치에서 실행 / 블록 스코프

생성자 함수

    객체 생성 방법 : 객체 리터럴 / 생성자 함수
      객체 리터럴 : 
        let user = {
            nmae: "mike",
            age : 30,
        }
      생성자 함수 : 생성자 함수를 알아보기위해 첫글자는 대문자로 사용 / 비슷한 형태의 객체를 만들때 사용 / 훨씬 빠르고 일관성있게 생성
        function User (name, age){
            this.name = name;
            this.age = age;
        }
        let user1 = new User('mike',30);
        let user2 = new User('jane',20);
    
        new 함수명()을 사용하면 this={ } 빈객체를 생성 -> name과 age의 property를 추가 -> this를 반환

객체 메소드
    computed property : 객체의 key값을 변수나 함수로 지정하는것([] 사용)
      let a = 'age';
      const user = {
          name : "mike",
          age : 30 ->  [a] : 30;// (computed property)
      }
    Method 
      - Object.assign(초기값,병합할 값) : 복제
      - Object.keys(반환할 객체) : 키를 배열로 반환
      - Object.values(반환할 객체) : 값을 배열로 반환
      - Object.entries(반환할 객체) : 키와 값을 배열로 반환
      - Object.fromEntries(반환할 객체) : 키와 값의 배열을 객체로 변환
        ex) const user = {
            name : "mike",
            age : 30,
            gender : "male"
        }
        Object.entries(user); -->[ ["name", "mike"], ["age", 30], ["gender", "male"] ]
 
Symbol : 유일한 식별자를 만들때 사용 (유일성 보장) 
        Object.keys() / Object.values() / Object.entries() 에서는 나타나지 않음 -> 원본을 건드리지 않고 속성 추가하여 다른사람이 만든 것에 자신만의 키와 값을 넣을수 있다
        Symbol('설명') -> 설명은 디버깅할때 편하다고 함
    ex) 
        const id = Symbol('id');
        const user = {
            name : "mike",
            age: 30,
            [id] : 'myid'
        }
        Symbol.for() : 전역 심볼(전역 변수처럼 이름이 같으면 같은 symbol을 가리쳐야할때 사용) -> 하나의 심볼만 보장
        - Symbol.keyfor(id1): Symbol키를 가져오고 있을때 사용 / 전역 Symbol이 아닐때는 id1.description을 사용
        - Object.getOwnPropertySymbols(user) -> 숨겨진 Symbol를 볼수 있음
    ex) 
        const id1 = Symbol.for('id');
        const id2 = Symbol.for('id');
        id1 === id2; -> true
        - Symbol.keyfor(id1): Symbol키를 가져오고 있을때 사용

Number : 
    toString(숫자) : 숫자 진수로 변경

Math : 
    Math.ceil(): 올림
    Math.floor() : 내림 
    Math.round() : 반올림
    Math.random() : 임의의 수를 뽑음
    Math.max() : 최대값
    Math.min() : 최소값
    Math.abs() : 절대값
    Math.pow() : 제곱수
    Math.sqrt() : 제곱
    변수.toFixed(자리수) : 자리수+1에서 반올림 ( 문자열로 반환 )
    isNaN() : NaN인지 아닌지 확인
    parseInt() : 숫자까지만 반환
    parseFloat() : 

문자열 : '' / "" / `` 로 사용
    toUpperCase()
    toLowerCase()
    indexOf()
    slice(n,m) : n부터 m-1까지 반환
    substring(n,m) : n과 m사이를 반환
    substr(n,m) : n부터 m개를 반환
    trim() : 앞과 뒤의 공백 제거
    repeat(n) : 문자열의 n번 반복
    
    문자열 비교 : a < z / A < a

배열 : 

    arr.splice(n,m,x,x,...) : n부터 m개 지우기(x로 추가) / 삭제된 요소 반환
    arr.slice(n,m) : n부터 m 전까지 반환
    arr.concat(arr2,arr3) : arr에 arr2,3을 합쳐서 반환
    arr.indexOf() : 있는지 확인하여 자리수를 나타냄
    arr.includes() : 찾아내기
    arr.find(fn) : 찾아내기 (함수)(해당하는 첫번째만 반환) / 있으면 true , 없으면 undefine
    arr.filter(fn) : find와 동일 (해당하는것들을 배열로 만들어 반환)
    arr.reverse() : 역순으로 재정렬
    arr.map(fn) : 특정기능을 수행하고 새로운 배열로 반환
    arr.join() : 배열을 문자열로 저장 
    
    arr.forEach(function (item,index,arr){ ... }) : 
        ex) 
            let arr = ["mike", "tom", "jane"]
            arr.forEach((item, index)=>{
                console.log(item)  --> "mike", "tom", "jane"
            })

    arr.sort(fn) : 배열 재정렬 
    arr.reduce()

구조 분해 할당 : 객체나 배열의 속성을 분해해 그 값을 변수에 담는 표현식
    ex)
        let [x, y] = [1,2]
        
나머지 매개변수(...), 전개 구문 (...)
    arguments : 함수로 넘어온 인수에 접근
    나머지 매개변수 : 정해지지 않은 인수의 개수를 배열로 나타냄
    
클로져 : 함수와 렉시컬 환경의 조합 / 함수가 생성될 당시의 외부 변수를 기억하여 생성 이후에도 계속 접근 가능

call / apply / bind : 함수에서 this 값을 가져올때 사용
    call(매개변수) : 매개변수를 this로 사용
        ex) 
        let mike = { name : "mike"};
        function showName (){ console.log(this.name)};
        showName() --> 값 없음;
        showName.call(mike) --> "mike"
    apply([매개변수]) : 매겨변수를 배열로 받는걸 제외하고 call과 동일
    bind : this 값을 영구적으로 바꿀수 있다.

상속 / prototype

class : 
    ex)
        class User2{
            constructor(name,age){
                this.name = name;
                this.age = age;
            }
            showName(){---> prototype에 저장됨
                console.log(this.name)
            }
        }
    extends : 상속 
    super : 부모에 사용된 함수 자식도 사용 가능(overriding)
*/



// const purpleCuteSlime = {
//   name: '슬라임',
//   attribute: 'cute',
//   color: 'purple'
// };

// const { color, ...rest } = purpleCuteSlime;
// console.log(color);
// console.log(rest);
// const numbers = [0, 1, 2, 3, 4, 5, 6];

// const [one, ...rest] = numbers;

// console.log(one);
// console.log(rest);

function max(...rest) {
    let tmp = Math.max(...rest)
    console.log(tmp)

    return rest;
}

const result = max(1, 2, 3, 4, 10, 5, 6, 7);


    </script>
</body>
</html>